{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * Both values are immutable: they can only be set once during construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner`'s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/DefiLendingDapp.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.24;\n\nimport \"./MyERC20Token.sol\";\n\n// 1，只有存款才计算利息\n// 2，抵押和存款概念要理清楚\n//      - 存款与取款是一个等级：牵扯到利息计算\n//      - 抵押、借款与还款是一个等级：\n// 3，输入的都要 x1e18 （因为有可能要输入小数，这些内容后续都要在前端处理）\n\ncontract DefiLendingDapp {\n\n    // ========================================== 数据结构\n    uint256 constant _collateralFactor = 80;  // 抵押因子(全局固定 标识 80%， 计算的时候需要除以 100)\n\n    // 当前借贷池子中代币的存储数据结构\n    /**\n     * 年化利率: 指如果资金借出或存入一整年所获得的利息比率。\n     *      利息 = 本金 × 年利率 × 时间（年）\n     *      存储的是放大100倍的值，计算的时候徐需要除以100 (避免浮点数计算)\n     *          - 如 1% 值为 1\n     *          - 如 100% 值为 100\n     * 抵押因子: 关键风险控制参数，它决定了用户可以用多少抵押资产借出其他资产\n     *      最大可借金额 = 抵押资产价值 × 抵押因子\n     *          - 用户抵押价值 $10,000 的ETH（抵押因子80%）\n     *              则最大可借：$10,000 × 80 = $8,000 其他资产\n     *      存储的是放大100倍的值，计算的时候徐需要除以100 (避免浮点数计算)\n     */\n    struct TokenInfo {\n        bool isAccepted;    // 是否接受该代币\n        uint256 totalSupply; // 总存款量\n        uint256 totalBorrowed; // 总借贷量\n        uint256 interestRate; // 年化利率（存储的是放大 100 倍的值（如5%存为5））\n        uint256 collateralFactor; // 抵押因子 (80 = 80%)\n    }\n\n    // 用户账户数据\n    struct Account {\n        uint256 deposited;  // 存款金额\n        uint256 borrowed;   // 借款金额\n        uint256 lastUpdated; // 上次更新时间\n    }\n\n    // ========================================== 变量定义\n    // 创建者\n    address public _owner;  \n    // 精度\n    uint256 public constant PRECISION = 1e18;  // 代币数量扩大了这个多倍\n\n    // 支持的代币列表\n    mapping(address => TokenInfo) public tokens; \n    // 代币价格 (1e18精度)\n    mapping(address => uint256) public tokenPrices;   // 价格也是乘以 1e18 了\n    // 用户存借数据: 用户--(对某个代币--操作信息)\n    mapping(address => mapping(address => Account)) public accounts; \n    // 新增存储所有token地址的变量（用于遍历所有token，找出某个用户的存、借信息）\n    address[] public acceptedTokens; // 存储所有支持的代币地址\n\n    // 一年的秒数\n    uint256 public constant SECONDS_PER_YEAR = 31536000; \n\n    // ========================================== 事件定义\n    event Deposit(address indexed user, address indexed token, uint256 amount);\n    event Withdraw(address indexed user, address indexed token, uint256 amount);\n    event Borrow(address indexed user, address indexed token, uint256 amount);\n    event Repay(address indexed user, address indexed token, uint256 amount);\n    event Liquidate(\n        address indexed liquidator,  // 清算人\n        address indexed borrower,  // 为债务人\n        address indexed collateralToken,  // 偿还债务代币A\n        uint256 collateralAmount,  // 多少数量\n        address debtToken,  // 使用代币B支付的\n        uint256 debtAmount  // 最终支付了B多少数量\n    );\n\n    // ========================================== 宏定义\n    // 仅仅owner可操作\n    modifier OnlyOwner() {\n        require(_owner == msg.sender, \"Only owner can call this!\");\n        _;\n    }\n\n    // ========================================== 函数定义\n    // 初始化合约\n    constructor() {\n        _owner = msg.sender;\n    }\n\n    // 添加合约中支持借贷的代币\n    function addToken(\n        address tokenAddress,  // 代币地址\n        uint256 interestRate\n    ) external OnlyOwner {\n        require(!tokens[tokenAddress].isAccepted, \"Token already added\");\n        // 抵押因子不能高（我自己不能亏）\n        require(_collateralFactor <= 9000, \"CollateralFactor too high\");\n\n        // 添加代币\n        tokens[tokenAddress] = TokenInfo({\n            isAccepted: true,  // 是否接受该代币\n            totalSupply: 0,  // 总存款量\n            totalBorrowed: 0,  // 总借贷量\n            interestRate: interestRate,  // 年化利率\n            collateralFactor: _collateralFactor  // 抵押因子\n        });\n\n        // 添加到支持列表\n        acceptedTokens.push(tokenAddress);\n    }\n\n    // 设置某个代币的价格 (仅owner)\n    function setTokenPrice(\n        address token, \n        uint256 price\n    ) external OnlyOwner {\n        tokenPrices[token] = price;  // 输入的已经 x1e18 了\n    }\n\n    // 存款\n    function deposit(\n        address token, \n        uint256 amount  // 输入数量也要记得乘 1e18，计算的时候再除掉（因为solidity不允许浮点运算）\n    ) external {\n        require(tokens[token].isAccepted, \"Token not supported\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(tokenPrices[token] > 0, \"Token price not set\");\n\n        // 更新调用者对于某个token的利息（前面有存款的则将利息计算出来添加到存款总额度中）\n        updateInterest(msg.sender, token);\n\n        // 转移代币（存入）\n        MyERC20Token(token).transferFrom(msg.sender, address(this), amount);\n\n        // 更新 当前用于对于当前token的 存款总量\n        accounts[msg.sender][token].deposited += amount;  // 记录存款数量\n        tokens[token].totalSupply += amount;  // 总存款量更新\n\n        emit Deposit(msg.sender, token, amount);\n    }\n\n    // 取款\n    function withdraw(\n        address token,   // 取某个token\n        uint256 amount  // 取多少钱（输入数量也要记得乘 1e18，计算的时候再除掉）\n    ) external {\n        require(amount > 0, \"Amount must be greater than 0\");\n\n        // 更新调用者当前token的利息\n        updateInterest(msg.sender, token);\n\n        // 保证存款数 大余 取款金额\n        require(accounts[msg.sender][token].deposited >= amount, \"Insufficient balance\");  \n\n        // 更新状态\n        accounts[msg.sender][token].deposited -= amount;  // 减去存款数量\n        tokens[token].totalSupply -= amount;  // 减去存款总量\n\n        // 转移代币（转到调用者账户）\n        MyERC20Token(token).transfer(msg.sender, amount);\n\n        emit Withdraw(msg.sender, token, amount);\n    }\n\n    // 抵押借款（将自身的币转到合约中，然后借出希望的币，不牵扯自身存进去的币）\n    function mortgageAndBorrow (\n        address mortgageToken,   // 要抵押的token\n        uint256 mortgageAmount,  // 要抵押的token数量 （输入要乘以 1e18）\n        address borrowToken   // 要借款的token\n    ) external {\n        require(tokens[mortgageToken].isAccepted && tokens[borrowToken].isAccepted, \"Token not supported\");\n        require(tokenPrices[mortgageToken] > 0 && tokenPrices[borrowToken] > 0, \"Token price not set\");\n        require(mortgageAmount > 0, \"mortgageAmount must be greater than 0\");\n\n        // 得到抵押人抵押mortgageAmount数量的mortgageToken可以借到代币borrowToken的数量borrowAmount\n        //      借款数量 = （抵押的数量(1e18) * 抵押代币的价格(1e18) * 抵押因子(100)）/ 借贷代币的价格(1e18) * 倍率 * 抵消一个1e18； （倍率是因为 抵押因子 扩大了100倍）\n        uint256 borrowAmount = (mortgageAmount * tokenPrices[mortgageToken] * tokens[mortgageToken].collateralFactor) / (tokenPrices[borrowToken] * 100);\n        require(borrowAmount > 0, \"borrowAmount must be greater than 0\");\n        require(MyERC20Token(borrowToken).balanceOf(address(this)) >= borrowAmount, \"Insufficient borrowAmount balance\");\n        require(MyERC20Token(mortgageToken).balanceOf(msg.sender) >= mortgageAmount, \"Insufficient mortgageAmount balance\");\n\n        // 更新状态\n        accounts[msg.sender][borrowToken].borrowed += borrowAmount;  // 借款代币的金额增加\n        tokens[borrowToken].totalBorrowed += borrowAmount;  // 代币的借贷总量增加\n\n        // 转移代币\n        MyERC20Token(mortgageToken).transferFrom(msg.sender, address(this), mortgageAmount);  // 给合约\n        MyERC20Token(borrowToken).transfer(msg.sender, borrowAmount);  // 给借款人\n\n        emit Borrow(msg.sender, borrowToken, borrowAmount);\n    }\n\n    // 还款\n    function repay(\n        address repayToken,  // 用于还款的token\n        uint256 repayAmount,  // 用于还款的数量  （输入要乘以 1e18）\n        address forRepayToken  // 要还款的token  \n    ) external {\n        require(tokens[repayToken].isAccepted && tokens[forRepayToken].isAccepted, \"Token not supported\");\n        require(tokenPrices[repayToken] > 0 && tokenPrices[forRepayToken] > 0, \"Token price not set\");\n        require(repayAmount > 0, \"repayAmount must be greater than 0\");\n\n        // 计算用户还款 代币repayToken数量为repayAmount时 可以得到代币forRepayToken的数量\n        //      可以得到的数量 = （用于还款代币数量(1e18) * 代币金额(1e18) * 倍率）/ 要还款的token价格(1e18) * 抵押因子(100) *  抵消一个1e18\n        uint256 forRepayAmountTemp = (repayAmount * tokenPrices[repayToken] * 100) / (tokenPrices[forRepayToken] * tokens[repayToken].collateralFactor);\n        uint256 forRepayAmount = min(forRepayAmountTemp, accounts[msg.sender][forRepayToken].borrowed);  // 得到当时借的最小值\n        require(forRepayAmount > 0, \"forRepayAmount must be greater than 0\");\n\n        // 更新状态\n        accounts[msg.sender][forRepayToken].borrowed -= forRepayAmount;\n        tokens[forRepayToken].totalBorrowed -= forRepayAmount;\n\n        // 转移代币（还款）\n        MyERC20Token(repayToken).transferFrom(msg.sender, address(this), repayAmount);  // 用户还款\n        MyERC20Token(forRepayToken).transfer(msg.sender, forRepayAmount);  // 归还借款人抵押物\n\n        emit Repay(msg.sender, repayToken, repayAmount);\n    }\n\n    // 清算（将抵押物的10%奖励给清算人）\n    function liquidate(\n        address borrower,  // 原来是谁借的这个钱\n        address collateralToken,  // 当时借钱的人抵押的什么代币（如ETH）\n        uint256 collateralTokenAmount,  // 清算人想偿还的债务数量（如1ETH） （输入要乘以 1e18）\n        address forRepayToken  // 清算人使用什么代币来还之前借钱人的债务（如USDT）\n    ) external {\n        require(tokens[collateralToken].isAccepted && tokens[forRepayToken].isAccepted, \"Token not supported\");\n        require(tokenPrices[collateralToken] > 0 && tokenPrices[forRepayToken] > 0, \"Token price not set\");\n        require(collateralTokenAmount > 0, \"repayAmount must be greater than 0\");\n\n        // 得到欠债人欠的真实的数量（得到用户想偿还 与 欠债人实际欠债 的最小数量）\n        uint256 actualCollateralAmount = min(collateralTokenAmount, accounts[borrower][collateralToken].borrowed);\n\n        // 计算清算人偿还collateralTokenAmount数量的collateralToken需要支付多少debtToken代币（偿还的collateralToken的10%奖励给清算人）\n        //      需要支付的数量 = （待还款代币数量(1e18) * 奖励10%(100) * 代币金额(1e18) ）/ 待还款代币抵押因子(100) * 用于清算的代币金额(1e18)\n        uint256 forRepayAmount = (actualCollateralAmount * 90 * tokenPrices[collateralToken]) / (tokens[collateralToken].collateralFactor * tokenPrices[forRepayToken]);\n        require(forRepayAmount > 0, \"forRepayAmount must be greater than 0\");\n\n        // 更新状态\n        accounts[borrower][collateralToken].borrowed -= actualCollateralAmount;  // 原来借款人的借款金额更新\n        tokens[collateralToken].totalBorrowed -= actualCollateralAmount;\n        \n        // 转移代币\n        MyERC20Token(forRepayToken).transferFrom(msg.sender, address(this), forRepayAmount);  // 清算人将实际支付的代币转到合约中\n        MyERC20Token(collateralToken).transfer(msg.sender, actualCollateralAmount);  // 然后将清算人应该得到的代币转移给清算人（奖励了10%）\n\n        emit Liquidate(msg.sender, borrower, collateralToken, actualCollateralAmount, forRepayToken, forRepayAmount);\n    }\n\n    // 更新利息（只有存款才有利息，借贷与抵押都没有利息）\n    function updateInterest(\n        address user, \n        address token\n    ) internal {\n        // 用户对某个代币的操作信息\n        Account storage account = accounts[user][token];\n        // 用户上次操作的时间距离现在多久了\n        uint256 timeElapsed = block.timestamp - account.lastUpdated;\n\n        // 因为当前要更新这个用户对于这个token的余额，所以我们这边直接计算出之前的利息加到存款中（让利息重新计算）\n        //      当前用户对当前token的操作有时间间隔 and 当前用户对当前token的存款数量>0（只有存款才产生利息）\n        if (timeElapsed > 0 && account.deposited > 0) {\n            // 计算前边的存款已经得到的所有利息（这些利息将会添加到现有的本金中进行复利，然后总量再加上新加入的，并且时间重置）\n            //      利息 = (现有存款数量 * 利率 * 存储时间) / (一年的时间 * 利率处理为百分数)\n            uint256 interest = (account.deposited * tokens[token].interestRate * timeElapsed) / (SECONDS_PER_YEAR * 100);\n\n            // 将利息添加到该用户的存款中（复利）\n            account.deposited += interest;\n            tokens[token].totalSupply += interest;  //添加该代币的存款总量\n        }\n        \n        // 更新该用户对于该token的最新操作时间\n        account.lastUpdated = block.timestamp;\n    }\n    \n    // 取小函数\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n}\n\n\n\n\n\n"
    },
    "contracts/LPSwap.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.24;\n\nimport \"./MyERC20Token.sol\";\n\n\n// 这里输入的PETH与PUSDT的单位需要是wei（也就是要乘以1e18），因为智能合约不能输入小数。\n//      实际使用过程中前端允许输入小数，然后前端转换为整数后调用智能合约。\n\ncontract LPSwap {\n    \n    // ========================================== 变量定义\n    // pair\n    MyERC20Token public _PETH;\n    MyERC20Token public _PUSDT;\n\n    // 流动性池子中pair各自的数量\n    uint256 public _reservePETH;\n    uint256 public _reservePUSDT;\n\n    // ========================================== 事件定义\n    event LiquidityAdded(address indexed provider, uint256 amountPETH, uint256 amountPUSDT);\n    event LiquidityRemoved(address indexed provider, uint256 amountPETH, uint256 amountPUSDT);\n    event Swapped(\n        address indexed user,\n        address indexed tokenIn,\n        uint256 amountIn,\n        address indexed tokenOut,\n        uint256 amountOut\n    );\n\n    // ========================================== 宏定义\n\n\n    // ========================================== 函数定义\n    constructor(address peth_addr, address pusdt_addr) {\n        _PETH = MyERC20Token(peth_addr);\n        _PUSDT = MyERC20Token(pusdt_addr);\n    }\n\n    // 添加流动性\n    function addLiquidity(uint256 amountPETH, uint256 amountPUSDT) external {\n        require( (amountPETH>0 && amountPUSDT>0), \"Amounts must be greater than 0!\");\n\n        // 首次添加直接根据输入数量确定，非首次添加需要计算是否满足K的（多余的U转回给调用者）\n        if (_reservePETH != 0 && _reservePUSDT != 0) {  // 非首次添加流动性\n\n            // 检查发送的U比例是否正确（）\n            //      交易保证k不变：x * y = k\n            //      添加流动性保证pair比例不变：x'/y' = x/y\n            uint256 expectedPUSDT = (amountPETH * _reservePUSDT) / _reservePETH;  // 使用 x'/y' = x/y 推\n            require(amountPUSDT >= expectedPUSDT, \"Need more PUSDT amount!\");\n\n            // 更新amountPUSDT，并且退还多的amountPUSDT\n            if (amountPUSDT > expectedPUSDT) {\n                amountPUSDT = expectedPUSDT;\n\n                // 退还多余的部分\n                uint256 excess = amountPUSDT - expectedPUSDT;\n                _PUSDT.transfer(msg.sender, excess);\n            }\n        }\n\n        // 转移代币\n        _PETH.transferFrom(msg.sender, address(this), amountPETH);\n        _PUSDT.transferFrom(msg.sender, address(this), amountPUSDT);\n\n        // 更新池子中pair的数量\n        _reservePETH += amountPETH;\n        _reservePUSDT += amountPUSDT;\n        \n        emit LiquidityAdded(msg.sender, amountPETH, amountPUSDT);\n    } \n\n    // 移除流动性（要移除的流动性百分比(1-100)）\n    function removeLiquidity(uint256 liquidityPercent) external {\n        require((liquidityPercent > 0 && liquidityPercent <= 100), \"Invalid percentage!\");\n\n        // 计算要移除的数量\n        uint256 amountPETH = (_reservePETH * liquidityPercent) / 100;\n        uint256 amountPUSDT = (_reservePUSDT * liquidityPercent) / 100;\n        require((amountPETH > 0 && amountPUSDT > 0), \"Insufficient liquidity\");\n        \n        // 直接更新储备\n        _reservePETH -= amountPETH;\n        _reservePUSDT -= amountPUSDT;\n        \n        // 返还代币给调用者\n        _PETH.transfer(msg.sender, amountPETH);\n        _PUSDT.transfer(msg.sender, amountPUSDT);\n        \n        emit LiquidityRemoved(msg.sender, amountPETH, amountPUSDT);\n    }\n\n    // 交换代币\n    function swap(\n        uint256 amountIn,\n        address inputToken\n    ) external returns (uint256 amountOut) {\n\n        require(amountIn > 0, \"Input amount must be positive\");\n        require(\n            inputToken == address(_PETH) || inputToken == address(_PUSDT),\n            \"Invalid input token\"\n        );\n        \n        // 得到输入与输出代币\n        bool isPETH = inputToken == address(_PETH);\n        uint256 reserveIn = isPETH ? _reservePETH : _reservePUSDT;\n        uint256 reserveOut = isPETH ? _reservePUSDT : _reservePETH;\n        \n        // 计算输出代币的数量：(reserveIn + amountIn) * (reserveOut - amountOut) = reserveIn * reserveOut\n        amountOut = (amountIn * reserveOut) / (reserveIn + amountIn);\n        \n        // 更新储备,执行转账\n        if (isPETH) {\n            _reservePETH += amountIn;\n            _reservePUSDT -= amountOut;\n\n            // 执行转账\n            _PETH.transferFrom(msg.sender, address(this), amountIn);\n            _PUSDT.transfer(msg.sender, amountOut);\n        } else {\n            _reservePUSDT += amountIn;\n            _reservePETH -= amountOut;\n\n            // 执行转账\n            _PUSDT.transferFrom(msg.sender, address(this), amountIn);\n            _PETH.transfer(msg.sender, amountOut);\n        }\n\n    }\n\n    // 获取当前价格(1 PETH = ? PUSDT)\n    function getPrice() public view returns (uint256) {\n        if (_reservePUSDT == 0 || _reservePETH == 0) revert(\"No liquidity\");\n\n        return (_reservePUSDT * 1e18) / _reservePETH; // 带18位精度\n    }\n\n\n}\n"
    },
    "contracts/MyERC20Token.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MyERC20Token is ERC20 {\n\n    // ========================================== 变量定义\n    address public _owner;  // 创建者\n\n    // ========================================== 事件定义\n    event Mint(address indexed to, uint256 amount);\n    event Burn(address indexed from, uint256 amount);\n\n    // ========================================== 宏定义\n    // 仅仅owner可操作\n    modifier OnlyOwner() {\n        require(_owner == msg.sender, \"Only owner can call this!\");\n        _;\n    }\n    // 某个账户可操作余额充足\n    modifier Balancesufficient(address addr, uint256 amount) {\n        require(balanceOf(addr) >= amount, \"Balance insufficient!\");\n        _;\n    }\n\n    // ========================================== 函数定义\n    // 构造函数\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {\n        _owner = msg.sender;\n    }\n\n    // mint函数（调用 ERC20 内部自己的 _mint 函数）\n    function mint(address to, uint256 amount) external OnlyOwner{\n        _mint(to, amount);\n        emit Mint(to, amount);\n    }\n\n    // burn函数（调用 ERC20 内部自己的 _burn 函数）\n    function burn(address from, uint256 amount) external OnlyOwner Balancesufficient(from, amount){\n        _burn(from, amount);\n\n        emit Burn(from, amount);\n    }\n\n}"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}